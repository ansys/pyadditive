
.. DO NOT EDIT.
.. THIS FILE WAS AUTOMATICALLY GENERATED BY SPHINX-GALLERY.
.. TO MAKE CHANGES, EDIT THE SOURCE PYTHON FILE:
.. "examples/04_additive_doe.py"
.. LINE NUMBERS ARE GIVEN BELOW.

.. only:: html

    .. note::
        :class: sphx-glr-download-link-note

        Click :ref:`here <sphx_glr_download_examples_04_additive_doe.py>`
        to download the full example code

.. rst-class:: sphx-glr-example-title

.. _sphx_glr_examples_04_additive_doe.py:


Design Of Experiments
=====================

This tutorial shows how you can use PyAdditive to run a design of experiments (DOE).
For this DOE we will vary laser power and scan speed over multiple single bead
simulations and plot the results.

Units are SI (m, kg, s, K) unless otherwise noted.

First, connect to the Additive service.

.. GENERATED FROM PYTHON SOURCE LINES 13-21

.. code-block:: default

    from matplotlib.colors import LinearSegmentedColormap as colorMap
    import matplotlib.pyplot as plt
    import numpy as np

    import ansys.additive as pyadditive

    additive = pyadditive.Additive()





.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none

    user data path: /home/runner/.local/share/ansys-pyadditive




.. GENERATED FROM PYTHON SOURCE LINES 22-26

Specify Parameters
---------------------------------
Here we create a list of ``SingleBeadInput`` objects with various laser power
and scan speed combinations.

.. GENERATED FROM PYTHON SOURCE LINES 26-48

.. code-block:: default


    bead_length = 0.001
    material = additive.get_material("17-4PH")
    initial_powers = [50, 350, 700]
    initial_scan_speeds = [0.35, 1.25, 2.5]
    # Use a comprehension to create a list of 9 machines
    machines = [
        pyadditive.AdditiveMachine(laser_power=p, scan_speed=s)
        for p in initial_powers
        for s in initial_scan_speeds
    ]
    inputs = []
    for count, machine in enumerate(machines):
        inputs.append(
            pyadditive.SingleBeadInput(
                id=f"single-bead-doe-{count}",
                material=material,
                machine=machine,
                bead_length=bead_length,
            )
        )








.. GENERATED FROM PYTHON SOURCE LINES 49-53

Run Simulations
---------------
The ``simulate`` method returns a list of summaries. In this case they are of
type :class:`SingleBeadSummary`.

.. GENERATED FROM PYTHON SOURCE LINES 53-56

.. code-block:: default


    summaries = additive.simulate(inputs)





.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none

    Executing 9 simulations
    Completed 1 of 9 simulations
    Completed 2 of 9 simulations
    Completed 3 of 9 simulations
    Completed 4 of 9 simulations
    Completed 5 of 9 simulations
    Completed 6 of 9 simulations
    Completed 7 of 9 simulations
    Completed 8 of 9 simulations
    Completed 9 of 9 simulations




.. GENERATED FROM PYTHON SOURCE LINES 57-59

Plot Individual Meltpool Statistics
-----------------------------------

.. GENERATED FROM PYTHON SOURCE LINES 59-86

.. code-block:: default


    summaries.sort(key=lambda s: (s.input.machine.laser_power, s.input.machine.scan_speed))
    nrows = len(initial_powers)
    ncols = len(initial_scan_speeds)
    fig, axs = plt.subplots(nrows, ncols, figsize=(15, 15), layout="constrained")
    for r in range(nrows):
        for c in range(ncols):
            i = r * nrows + c
            mp = summaries[i].melt_pool
            axs[r][c].plot(mp.laser_x, mp.width, label="width")
            axs[r][c].plot(mp.laser_x, mp.reference_width, label="ref width")
            axs[r][c].plot(mp.laser_x, mp.depth, label="depth")
            axs[r][c].plot(mp.laser_x, mp.reference_depth, label="ref depth")
            axs[r][c].plot(mp.laser_x, mp.length, label="length")
            axs[r][c].legend()
            axs[r][c].set_xlabel(f"Bead Length (m)")
            axs[r][c].set_ylabel(f"Melt Pool (m)")
            title = (
                "Power "
                + str(summaries[i].input.machine.laser_power)
                + "W, Scan Speed "
                + str(summaries[i].input.machine.scan_speed)
                + "m/s"
            )
            axs[r][c].set_title(title)





.. image-sg:: /examples/images/sphx_glr_04_additive_doe_001.png
   :alt: Power 50W, Scan Speed 0.35m/s, Power 50W, Scan Speed 1.25m/s, Power 50W, Scan Speed 2.5m/s, Power 350W, Scan Speed 0.35m/s, Power 350W, Scan Speed 1.25m/s, Power 350W, Scan Speed 2.5m/s, Power 700W, Scan Speed 0.35m/s, Power 700W, Scan Speed 1.25m/s, Power 700W, Scan Speed 2.5m/s
   :srcset: /examples/images/sphx_glr_04_additive_doe_001.png
   :class: sphx-glr-single-img





.. GENERATED FROM PYTHON SOURCE LINES 87-91

Plot Meltpool Average Depth Over Width Verses Laser Power And Scan Speed
------------------------------------------------------------------------
Here we create a "watermelon" plot to visualize the optimal laser power
and scan speed combinations.

.. GENERATED FROM PYTHON SOURCE LINES 91-134

.. code-block:: default


    # Gather plot values
    powers = []
    scan_speeds = []
    depth_over_width = []

    for s in summaries:
        mp = s.melt_pool
        ave_width = np.average(mp.width)
        ave_depth = np.average(mp.depth)
        powers.append(s.input.machine.laser_power)
        scan_speeds.append(s.input.machine.scan_speed)
        depth_over_width.append(ave_depth / ave_width if ave_width else 0)

    # Create plot, adjust dwMin and dwMax for desired acceptable range.
    dwMin = 0.37
    dwMax = 0.6
    contour_gradient = []
    marker_colors = []
    fig, ax = plt.subplots(figsize=(20, 10))
    for i in range(len(depth_over_width)):
        if dwMin < depth_over_width[i] < dwMax:
            contour_gradient.append(0)
            marker_colors.append("blue")
        else:
            contour_gradient.append(abs(((dwMax + dwMin) / 2) - depth_over_width[i]))
            marker_colors.append("black")
        txt = "{}".format(round(depth_over_width[i], 2))
        ax.annotate(
            str(txt),
            (scan_speeds[i], powers[i] + 25),
            verticalalignment="top",
            horizontalalignment="center",
        )

    colMap = colorMap.from_list("", ["green", "yellow", "red", "red"])
    ax.tricontourf(scan_speeds, powers, contour_gradient, cmap=colMap, levels=255)
    ax.scatter(scan_speeds, powers, c=marker_colors, marker="d", s=100, facecolor="none")
    ax.use_sticky_edges = False
    ax.margins(0.075)
    ax.set_title("Melt Pool Depth/Width")
    ax.set_xlabel(f"Laser Scan Speed (m/s)")
    ax.set_ylabel(f"Laser Power (W)")



.. image-sg:: /examples/images/sphx_glr_04_additive_doe_002.png
   :alt: Melt Pool Depth/Width
   :srcset: /examples/images/sphx_glr_04_additive_doe_002.png
   :class: sphx-glr-single-img


.. rst-class:: sphx-glr-script-out

 Out:

 .. code-block:: none


    Text(208.34722222222223, 0.5, 'Laser Power (W)')




.. rst-class:: sphx-glr-timing

   **Total running time of the script:** ( 8 minutes  11.865 seconds)


.. _sphx_glr_download_examples_04_additive_doe.py:


.. only :: html

 .. container:: sphx-glr-footer
    :class: sphx-glr-footer-example



  .. container:: sphx-glr-download sphx-glr-download-python

     :download:`Download Python source code: 04_additive_doe.py <04_additive_doe.py>`



  .. container:: sphx-glr-download sphx-glr-download-jupyter

     :download:`Download Jupyter notebook: 04_additive_doe.ipynb <04_additive_doe.ipynb>`


.. only:: html

 .. rst-class:: sphx-glr-signature

    `Gallery generated by Sphinx-Gallery <https://sphinx-gallery.github.io>`_
